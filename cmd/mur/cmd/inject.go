package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/mur-run/mur-core/internal/core/pattern"
	"github.com/spf13/cobra"
)

var injectCmd = &cobra.Command{
	Use:   "inject [target-dir]",
	Short: "Inject patterns into a project's CLAUDE.md",
	Long: `Inject relevant patterns into a project's CLAUDE.md or AGENTS.md file.

This adds a "## Learned Patterns" section with patterns relevant to the project.
Existing sections are updated; new sections are appended.

Examples:
  mur inject .                         # Inject into current project
  mur inject ~/Projects/myapp          # Inject into specific project
  mur inject . --tag backend           # Only inject 'backend' patterns
  mur inject . --file AGENTS.md        # Use AGENTS.md instead of CLAUDE.md
  mur inject . --min-effectiveness 0.7 # Only high-effectiveness patterns
  mur inject . --dry-run               # Preview without writing`,
	Args: cobra.MaximumNArgs(1),
	RunE: runInject,
}

var (
	injectFile            string
	injectTag             string
	injectMinEffectiveness float64
	injectDryRun          bool
	injectAppend          bool
)

func init() {
	injectCmd.Hidden = true // Use 'mur sync' instead
	rootCmd.AddCommand(injectCmd)

	injectCmd.Flags().StringVarP(&injectFile, "file", "f", "CLAUDE.md", "Target file name")
	injectCmd.Flags().StringVarP(&injectTag, "tag", "t", "", "Filter by tag")
	injectCmd.Flags().Float64Var(&injectMinEffectiveness, "min-effectiveness", 0.5, "Minimum effectiveness score")
	injectCmd.Flags().BoolVar(&injectDryRun, "dry-run", false, "Preview without writing")
	injectCmd.Flags().BoolVar(&injectAppend, "append", false, "Append instead of updating section")
}

func runInject(cmd *cobra.Command, args []string) error {
	targetDir := "."
	if len(args) > 0 {
		targetDir = args[0]
	}

	// Resolve target directory
	targetDir, err := filepath.Abs(targetDir)
	if err != nil {
		return fmt.Errorf("cannot resolve path: %w", err)
	}

	targetPath := filepath.Join(targetDir, injectFile)

	// Get patterns
	store, err := pattern.DefaultStore()
	if err != nil {
		return fmt.Errorf("cannot access pattern store: %w", err)
	}

	var patterns []pattern.Pattern
	if injectTag != "" {
		patterns, err = store.GetByTag(injectTag)
	} else {
		patterns, err = store.GetActive()
	}
	if err != nil {
		return fmt.Errorf("cannot load patterns: %w", err)
	}

	// Filter by effectiveness
	var filtered []pattern.Pattern
	for _, p := range patterns {
		if p.Learning.Effectiveness >= injectMinEffectiveness {
			filtered = append(filtered, p)
		}
	}
	patterns = filtered

	if len(patterns) == 0 {
		fmt.Println("No patterns found matching criteria.")
		return nil
	}

	// Generate patterns section
	section := generatePatternsSection(patterns)

	// Read existing file or create new
	var content string
	if data, err := os.ReadFile(targetPath); err == nil {
		content = string(data)
	} else if os.IsNotExist(err) {
		content = fmt.Sprintf("# %s\n\n", strings.TrimSuffix(injectFile, filepath.Ext(injectFile)))
	} else {
		return fmt.Errorf("cannot read file: %w", err)
	}

	// Update or append section
	var newContent string
	if injectAppend {
		newContent = content + "\n" + section
	} else {
		newContent = updateSection(content, section)
	}

	// Output
	if injectDryRun {
		fmt.Println("=== DRY RUN ===")
		fmt.Printf("Would write to: %s\n", targetPath)
		fmt.Printf("Patterns: %d\n", len(patterns))
		fmt.Println()
		fmt.Println("=== Section Content ===")
		fmt.Println(section)
		return nil
	}

	// Write file
	if err := os.WriteFile(targetPath, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("cannot write file: %w", err)
	}

	fmt.Printf("âœ… Injected %d patterns into %s\n", len(patterns), targetPath)
	return nil
}

func generatePatternsSection(patterns []pattern.Pattern) string {
	var sb strings.Builder

	sb.WriteString("## Learned Patterns\n\n")
	sb.WriteString("<!-- mur:inject:start -->\n")
	sb.WriteString(fmt.Sprintf("*Auto-generated by mur. %d patterns.*\n\n", len(patterns)))

	for _, p := range patterns {
		sb.WriteString(fmt.Sprintf("### %s\n\n", p.Name))

		if p.Description != "" {
			sb.WriteString(fmt.Sprintf("%s\n\n", p.Description))
		}

		// Tags
		var tags []string
		for _, t := range p.Tags.Confirmed {
			tags = append(tags, "`"+t+"`")
		}
		for _, ts := range p.Tags.Inferred {
			if ts.Confidence >= 0.7 {
				tags = append(tags, "`"+ts.Tag+"`")
			}
		}
		if len(tags) > 0 {
			sb.WriteString(fmt.Sprintf("**Tags:** %s\n\n", strings.Join(tags, " ")))
		}

		// Content (truncate if too long)
		content := p.Content
		if len(content) > 500 {
			content = content[:500] + "..."
		}
		sb.WriteString("```\n")
		sb.WriteString(content)
		if !strings.HasSuffix(content, "\n") {
			sb.WriteString("\n")
		}
		sb.WriteString("```\n\n")
	}

	sb.WriteString("<!-- mur:inject:end -->\n")

	return sb.String()
}

func updateSection(content, section string) string {
	// Pattern to find existing mur section
	startMarker := "<!-- mur:inject:start -->"
	endMarker := "<!-- mur:inject:end -->"

	startIdx := strings.Index(content, startMarker)
	endIdx := strings.Index(content, endMarker)

	if startIdx != -1 && endIdx != -1 && endIdx > startIdx {
		// Find the ## header before start marker
		headerPattern := regexp.MustCompile(`(?m)^## Learned Patterns\s*\n`)
		loc := headerPattern.FindStringIndex(content[:startIdx])

		if loc != nil {
			// Replace from header to end marker
			before := content[:loc[0]]
			after := content[endIdx+len(endMarker):]
			return strings.TrimRight(before, "\n") + "\n\n" + section + strings.TrimLeft(after, "\n")
		}

		// Just replace between markers
		before := content[:startIdx]
		after := content[endIdx+len(endMarker):]
		return before + section[strings.Index(section, startMarker):] + after
	}

	// No existing section - append
	return strings.TrimRight(content, "\n") + "\n\n" + section
}
