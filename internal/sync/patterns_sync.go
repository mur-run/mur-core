// Package sync provides pattern synchronization to AI CLI tools.
package sync

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/mur-run/mur-core/internal/core/pattern"
)

// PatternTarget defines where patterns are synced to for each CLI.
type PatternTarget struct {
	Name       string
	SkillsDir  string // relative to home
	FileName   string // the skill file name
	Format     string // "markdown" or "yaml"
}

// DefaultPatternTargets returns all supported CLI targets.
func DefaultPatternTargets() []PatternTarget {
	return []PatternTarget{
		// Terminal CLIs
		{Name: "Claude Code", SkillsDir: ".claude/skills", FileName: "mur-patterns.md", Format: "markdown"},
		{Name: "Gemini CLI", SkillsDir: ".gemini/skills", FileName: "mur-patterns.md", Format: "markdown"},
		{Name: "Codex", SkillsDir: ".codex", FileName: "instructions.md", Format: "markdown"},
		{Name: "Auggie", SkillsDir: ".augment/skills", FileName: "mur-patterns.md", Format: "markdown"},
		{Name: "Aider", SkillsDir: ".aider", FileName: "conventions.md", Format: "markdown"},
		{Name: "OpenCode", SkillsDir: ".opencode", FileName: "instructions.md", Format: "markdown"},
		// IDE integrations
		{Name: "Continue", SkillsDir: ".continue/rules", FileName: "mur-patterns.md", Format: "markdown"},
		{Name: "Cursor", SkillsDir: ".cursor/rules", FileName: "mur-patterns.md", Format: "markdown"},
		{Name: "Windsurf", SkillsDir: ".windsurf/rules", FileName: "mur-patterns.md", Format: "markdown"},
		{Name: "GitHub Copilot", SkillsDir: ".github", FileName: "copilot-instructions.md", Format: "markdown"},
	}
}

// SyncPatternsToAllCLIs syncs patterns from ~/.mur/patterns/ to all CLI skill directories.
func SyncPatternsToAllCLIs() ([]SyncResult, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("cannot determine home directory: %w", err)
	}

	// Load patterns
	store, err := pattern.DefaultStore()
	if err != nil {
		return nil, fmt.Errorf("cannot access pattern store: %w", err)
	}

	patterns, err := store.GetActive()
	if err != nil {
		return nil, fmt.Errorf("cannot load patterns: %w", err)
	}

	if len(patterns) == 0 {
		return []SyncResult{{
			Target:  "patterns",
			Success: true,
			Message: "No patterns to sync",
		}}, nil
	}

	// Sort patterns by effectiveness
	sort.Slice(patterns, func(i, j int) bool {
		return patterns[i].Learning.Effectiveness > patterns[j].Learning.Effectiveness
	})

	// Generate skill content
	content := generatePatternSkill(patterns)

	// Sync to each target
	var results []SyncResult
	for _, target := range DefaultPatternTargets() {
		targetDir := filepath.Join(home, target.SkillsDir)
		targetPath := filepath.Join(targetDir, target.FileName)

		// Create directory if needed
		if err := os.MkdirAll(targetDir, 0755); err != nil {
			results = append(results, SyncResult{
				Target:  target.Name,
				Success: false,
				Message: fmt.Sprintf("Cannot create directory: %v", err),
			})
			continue
		}

		// For Codex, append to existing instructions.md
		if target.Name == "Codex" {
			content = generateCodexInstructions(patterns, targetPath)
		}

		// Write skill file
		if err := os.WriteFile(targetPath, []byte(content), 0644); err != nil {
			results = append(results, SyncResult{
				Target:  target.Name,
				Success: false,
				Message: fmt.Sprintf("Cannot write file: %v", err),
			})
			continue
		}

		results = append(results, SyncResult{
			Target:  target.Name,
			Success: true,
			Message: fmt.Sprintf("Synced %d patterns", len(patterns)),
		})
	}

	return results, nil
}

// generatePatternSkill generates a markdown skill file from patterns.
func generatePatternSkill(patterns []pattern.Pattern) string {
	var sb strings.Builder

	sb.WriteString("# Learned Patterns\n\n")
	sb.WriteString("*Auto-generated by [mur](https://github.com/mur-run/mur-core). ")
	sb.WriteString(fmt.Sprintf("Updated: %s*\n\n", time.Now().Format("2006-01-02 15:04")))
	sb.WriteString("These patterns were learned from previous development sessions. ")
	sb.WriteString("Apply them when relevant.\n\n")
	sb.WriteString("---\n\n")

	for _, p := range patterns {
		sb.WriteString(fmt.Sprintf("## %s\n\n", p.Name))

		if p.Description != "" {
			sb.WriteString(fmt.Sprintf("%s\n\n", p.Description))
		}

		// Tags
		var tags []string
		for _, t := range p.Tags.Confirmed {
			tags = append(tags, "`"+t+"`")
		}
		for _, ts := range p.Tags.Inferred {
			if ts.Confidence >= 0.7 {
				tags = append(tags, "`"+ts.Tag+"`")
			}
		}
		if len(tags) > 0 {
			sb.WriteString(fmt.Sprintf("**Tags:** %s\n\n", strings.Join(tags, " ")))
		}

		// Content
		content := p.Content
		if len(content) > 1000 {
			content = content[:1000] + "\n\n*(truncated)*"
		}
		sb.WriteString(content)
		if !strings.HasSuffix(content, "\n") {
			sb.WriteString("\n")
		}
		sb.WriteString("\n---\n\n")
	}

	sb.WriteString("\n*Run `mur sync` to update these patterns.*\n")

	return sb.String()
}

// generateCodexInstructions generates Codex-specific instructions format.
func generateCodexInstructions(patterns []pattern.Pattern, existingPath string) string {
	var sb strings.Builder

	// Read existing content if file exists
	if data, err := os.ReadFile(existingPath); err == nil {
		content := string(data)
		// Remove old mur section if present
		if idx := strings.Index(content, "<!-- mur:start -->"); idx != -1 {
			if endIdx := strings.Index(content, "<!-- mur:end -->"); endIdx != -1 {
				content = content[:idx] + content[endIdx+len("<!-- mur:end -->"):]
			}
		}
		sb.WriteString(strings.TrimSpace(content))
		sb.WriteString("\n\n")
	}

	// Add mur section
	sb.WriteString("<!-- mur:start -->\n")
	sb.WriteString("## Learned Patterns (mur)\n\n")

	for _, p := range patterns {
		sb.WriteString(fmt.Sprintf("### %s\n", p.Name))
		if p.Description != "" {
			sb.WriteString(fmt.Sprintf("%s\n", p.Description))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("<!-- mur:end -->\n")

	return sb.String()
}

// SyncPatternsToTarget syncs patterns to a specific CLI target.
func SyncPatternsToTarget(targetName string) (*SyncResult, error) {
	for _, target := range DefaultPatternTargets() {
		if strings.EqualFold(target.Name, targetName) {
			results, err := SyncPatternsToAllCLIs()
			if err != nil {
				return nil, err
			}
			for _, r := range results {
				if strings.EqualFold(r.Target, targetName) {
					return &r, nil
				}
			}
		}
	}
	return nil, fmt.Errorf("unknown target: %s", targetName)
}
